<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Edge TTS WebSocket Demo</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: Inter, system-ui, sans-serif;
      }
      body {
        margin: 2rem;
        max-width: 900px;
      }
      textarea {
        width: 100%;
        min-height: 160px;
        margin-bottom: 1rem;
        padding: 0.7rem;
        font-size: 1rem;
      }
      select,
      input,
      button {
        padding: 0.6rem;
        font-size: 1rem;
      }
      .controls {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        flex-wrap: wrap;
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }
      .control-group input {
        width: 7rem;
      }
      .actions {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        margin-bottom: 1rem;
      }
      #status {
        min-height: 1.4rem;
        margin-bottom: 1rem;
      }
      audio {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h1>Edge TTS WebSocket Demo</h1>
    <p>
      Enter text and synthesize speech using <code>edge-tts</code>. Communication between frontend and backend happens via
      WebSocket.
    </p>

    <textarea id="textInput" placeholder="Type text to synthesize..."></textarea>

    <div class="actions controls">
      <div class="control-group">
        <label for="voiceSelect">Voice:</label>
        <select id="voiceSelect">
          <option value="en-US-JennyNeural">en-US-JennyNeural</option>
          <option value="en-US-GuyNeural">en-US-GuyNeural</option>
          <option value="en-GB-SoniaNeural">en-GB-SoniaNeural</option>
          <option value="ja-JP-NanamiNeural">ja-JP-NanamiNeural</option>
        </select>
      </div>
      <div class="control-group">
        <label for="rateInput">Rate:</label>
        <input id="rateInput" type="text" value="+0%" placeholder="e.g. +15%" />
      </div>
      <div class="control-group">
        <label for="pitchInput">Pitch:</label>
        <input id="pitchInput" type="text" value="+0Hz" placeholder="e.g. +5Hz" />
      </div>
      <div class="control-group">
        <label for="wsUrlInput">Backend WS URL:</label>
        <input id="wsUrlInput" type="text" placeholder="wss://example.com/ws" style="width: 18rem" />
      </div>
      <button id="connectBtn" type="button">Connect</button>
      <button id="synthesizeBtn" type="button">Synthesize</button>
      <a id="downloadLink" href="#" download="speech.mp3" style="display: none">Download audio</a>
    </div>

    <div id="status"></div>
    <audio id="audioPlayer" controls></audio>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
      const statusEl = document.getElementById("status");
      const textInput = document.getElementById("textInput");
      const voiceSelect = document.getElementById("voiceSelect");
      const rateInput = document.getElementById("rateInput");
      const pitchInput = document.getElementById("pitchInput");
      const wsUrlInput = document.getElementById("wsUrlInput");
      const connectBtn = document.getElementById("connectBtn");
      const synthesizeBtn = document.getElementById("synthesizeBtn");
      const audioPlayer = document.getElementById("audioPlayer");
      const downloadLink = document.getElementById("downloadLink");

      let socket;
      let currentObjectUrl;

      function htmlToText(input) {
        const doc = new DOMParser().parseFromString(input, "text/html");
        return (doc.body.textContent || "").replace(/\s+\n/g, "\n").trim();
      }

      function markdownToText(input) {
        if (!window.marked || typeof window.marked.parse !== "function") {
          return input.trim();
        }

        const html = window.marked.parse(input);
        return htmlToText(html);
      }

      function isLikelyHtml(input) {
        return /<\/?[a-z][\s\S]*>/i.test(input);
      }

      function isLikelyMarkdown(input) {
        return /(^|\n)(#{1,6}\s|[-*+]\s|\d+\.\s|>\s|```)|\[[^\]]+\]\([^)]+\)|\*\*[^*]+\*\*|_[^_]+_/m.test(input);
      }

      function normalizeInputText(input) {
        if (isLikelyHtml(input)) {
          return htmlToText(input);
        }

        if (isLikelyMarkdown(input)) {
          return markdownToText(input);
        }

        return input.trim();
      }

      function setStatus(message, isError = false) {
        statusEl.textContent = message;
        statusEl.style.color = isError ? "crimson" : "inherit";
      }

      function getDefaultWsUrl() {
        const protocol = window.location.protocol === "https:" ? "wss" : "ws";
        return `${protocol}://${window.location.host}/ws`;
      }

      function getConfiguredWsUrl() {
        return wsUrlInput.value.trim() || getDefaultWsUrl();
      }

      function connectWebSocket() {
        const wsUrl = getConfiguredWsUrl();
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.close();
        }

        setStatus(`Connecting to ${wsUrl}...`);
        socket = new WebSocket(wsUrl);

        socket.addEventListener("open", () => {
          setStatus("WebSocket connected.");
        });

        socket.addEventListener("close", () => {
          setStatus("WebSocket disconnected.", true);
        });

        socket.addEventListener("message", (event) => {
          const payload = JSON.parse(event.data);

          if (payload.type === "ready" || payload.type === "status") {
            setStatus(payload.message);
            return;
          }

          if (payload.type === "error") {
            setStatus(payload.message, true);
            return;
          }

          if (payload.type === "audio") {
            const binary = atob(payload.audio_base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
              bytes[i] = binary.charCodeAt(i);
            }

            const blob = new Blob([bytes], { type: payload.format || "audio/mpeg" });
            if (currentObjectUrl) URL.revokeObjectURL(currentObjectUrl);
            currentObjectUrl = URL.createObjectURL(blob);

            audioPlayer.src = currentObjectUrl;
            audioPlayer.play().catch(() => {
              // autoplay might be blocked by browser policy
            });

            downloadLink.href = currentObjectUrl;
            downloadLink.download = payload.filename || "speech.mp3";
            downloadLink.style.display = "inline-block";

            setStatus("Synthesis complete. Playing audio and download available.");
          }
        });
      }

      connectBtn.addEventListener("click", () => {
        connectWebSocket();
      });

      synthesizeBtn.addEventListener("click", () => {
        const text = normalizeInputText(textInput.value);
        if (!text) {
          setStatus("Please enter text first.", true);
          return;
        }

        if (!socket || socket.readyState !== WebSocket.OPEN) {
          setStatus("WebSocket is not connected yet.", true);
          return;
        }

        socket.send(
          JSON.stringify({
            action: "synthesize",
            text,
            voice: voiceSelect.value,
            rate: rateInput.value.trim() || "+0%",
            pitch: pitchInput.value.trim() || "+0Hz",
          })
        );
      });

      wsUrlInput.value = getDefaultWsUrl();
      connectWebSocket();
    </script>
  </body>
</html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Edge TTS HTTP Demo</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: Inter, system-ui, sans-serif;
      }
      body {
        margin: 2rem;
        max-width: 900px;
      }
      textarea {
        width: 100%;
        min-height: 160px;
        margin-bottom: 1rem;
        padding: 0.7rem;
        font-size: 1rem;
      }
      select,
      input,
      button {
        padding: 0.6rem;
        font-size: 1rem;
      }
      .controls {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        flex-wrap: wrap;
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }
      .control-group input {
        width: 7rem;
      }
      .actions {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        margin-bottom: 1rem;
      }
      .history-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 1.2rem;
        margin-bottom: 0.6rem;
      }
      .history-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .history-item {
        border: 1px solid color-mix(in srgb, currentColor 25%, transparent);
        border-radius: 8px;
        padding: 0.7rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .history-item-main {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
      }
      .history-meta {
        font-size: 0.9rem;
        opacity: 0.85;
      }
      .history-preview {
        white-space: pre-wrap;
        word-break: break-word;
        margin: 0;
      }
      .history-item button {
        width: fit-content;
      }
      #status {
        min-height: 1.4rem;
        margin-bottom: 1rem;
      }
      audio {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h1>Edge TTS HTTP Demo</h1>
    <p>
      Enter text and synthesize speech using <code>edge-tts</code>. Communication between frontend and backend happens via
      HTTP (GET/POST).
    </p>

    <textarea id="textInput" placeholder="Type text to synthesize..."></textarea>

    <div class="actions controls">
      <div class="control-group">
        <label for="voiceSelect">Voice:</label>
        <select id="voiceSelect">
          <option value="en-US-JennyNeural">en-US-JennyNeural</option>
          <option value="en-US-GuyNeural">en-US-GuyNeural</option>
          <option value="en-GB-SoniaNeural">en-GB-SoniaNeural</option>
          <option value="ja-JP-NanamiNeural">ja-JP-NanamiNeural</option>
        </select>
      </div>
      <div class="control-group">
        <label for="rateInput">Rate:</label>
        <input id="rateInput" type="text" value="+0%" placeholder="e.g. +15%" />
      </div>
      <div class="control-group">
        <label for="pitchInput">Pitch:</label>
        <input id="pitchInput" type="text" value="+0Hz" placeholder="e.g. +5Hz" />
      </div>
      <button id="synthesizeBtn" type="button">Synthesize</button>
      <a id="downloadLink" href="#" download="speech.mp3" style="display: none">Download audio</a>
    </div>

    <div id="status"></div>
    <audio id="audioPlayer" controls></audio>

    <div class="history-header">
      <h2>Synthesis History</h2>
      <button id="refreshHistoryBtn" type="button">Refresh</button>
    </div>
    <ul id="historyList" class="history-list"></ul>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
      const statusEl = document.getElementById("status");
      const textInput = document.getElementById("textInput");
      const voiceSelect = document.getElementById("voiceSelect");
      const rateInput = document.getElementById("rateInput");
      const pitchInput = document.getElementById("pitchInput");
      const synthesizeBtn = document.getElementById("synthesizeBtn");
      const audioPlayer = document.getElementById("audioPlayer");
      const downloadLink = document.getElementById("downloadLink");
      const historyList = document.getElementById("historyList");
      const refreshHistoryBtn = document.getElementById("refreshHistoryBtn");

      const STORAGE_KEYS = {
        text: "edgeTtsWebUi.text",
        voice: "edgeTtsWebUi.voice",
        rate: "edgeTtsWebUi.rate",
        pitch: "edgeTtsWebUi.pitch",
      };

      let historyPollTimer;

      function escapeHtml(value) {
        return value
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll("\"", "&quot;")
          .replaceAll("'", "&#39;");
      }

      function truncateText(value, maxLength = 220) {
        return value.length > maxLength ? `${value.slice(0, maxLength)}...` : value;
      }

      function playHistoryAudio(recordId) {
        const audioUrl = `/api/history/${encodeURIComponent(recordId)}/audio`;
        audioPlayer.src = audioUrl;
        audioPlayer.play().catch(() => {
          // autoplay might be blocked by browser policy
        });
        downloadLink.href = audioUrl;
        downloadLink.download = `${recordId}.mp3`;
        downloadLink.style.display = "inline-block";
      }

      function renderHistory(records) {
        if (!records.length) {
          historyList.innerHTML = "<li class=\"history-item\">No synthesis history yet.</li>";
          return;
        }

        historyList.innerHTML = records
          .map((record) => {
            const createdAt = new Date(record.created_at);
            const createdAtLabel = Number.isNaN(createdAt.getTime()) ? "Unknown time" : createdAt.toLocaleString();
            const preview = escapeHtml(truncateText(record.text || ""));
            const status = escapeHtml(record.status || "unknown");
            const canPlay = Boolean(record.audio_filename);
            const canStop = record.status === "in_progress" || record.status === "stopping";
            const actionButtons = [
              canPlay
                ? `<button type=\"button\" data-record-id=\"${escapeHtml(record.id || "")}\">Play</button>`
                : "",
              canStop
                ? `<button type=\"button\" data-stop-record-id=\"${escapeHtml(record.id || "")}\">Stop</button>`
                : "",
            ]
              .filter(Boolean)
              .join(" ");

            return `
              <li class=\"history-item\">
                <div class=\"history-item-main\">
                  <div class=\"history-meta\">
                    <strong>${escapeHtml(record.voice || "unknown")}</strong>
                    <div>${escapeHtml(record.rate || "")}, ${escapeHtml(record.pitch || "")}</div>
                    <div>${escapeHtml(createdAtLabel)}</div>
                    <div>Status: <strong>${status}</strong></div>
                  </div>
                  <div class="actions">${actionButtons || "<span></span>"}</div>
                </div>
                <p class=\"history-preview\">${preview}</p>
              </li>
            `;
          })
          .join("");

        historyList.querySelectorAll("button[data-record-id]").forEach((button) => {
          button.addEventListener("click", () => {
            const recordId = button.getAttribute("data-record-id");
            if (!recordId) return;
            playHistoryAudio(recordId);
          });
        });

        historyList.querySelectorAll("button[data-stop-record-id]").forEach((button) => {
          button.addEventListener("click", async () => {
            const recordId = button.getAttribute("data-stop-record-id");
            if (!recordId) return;

            try {
              const response = await fetch(`/api/command`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  action: "stop",
                  record_id: recordId,
                }),
              });
              if (!response.ok) {
                throw new Error(`Stop request failed: ${response.status}`);
              }

              setStatus("Stop requested for selected synthesis.");
              loadHistory();
            } catch (error) {
              setStatus(`Failed to stop synthesis: ${String(error)}`, true);
            }
          });
        });
      }

      async function loadHistory() {
        try {
          const response = await fetch("/api/command", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action: "history_list" }),
          });
          if (!response.ok) {
            throw new Error(`History request failed: ${response.status}`);
          }

          const payload = await response.json();
          const records = Array.isArray(payload.items) ? payload.items : [];
          renderHistory(records);
        } catch (error) {
          historyList.innerHTML = `<li class=\"history-item\">Failed to load history: ${escapeHtml(String(error))}</li>`;
        }
      }

      function htmlToText(input) {
        const doc = new DOMParser().parseFromString(input, "text/html");
        return (doc.body.textContent || "").replace(/\s+\n/g, "\n").trim();
      }

      function markdownToText(input) {
        if (!window.marked || typeof window.marked.parse !== "function") {
          return input.trim();
        }

        const html = window.marked.parse(input);
        return htmlToText(html);
      }

      function isLikelyHtml(input) {
        return /<\/?[a-z][\s\S]*>/i.test(input);
      }

      function isLikelyMarkdown(input) {
        return /(^|\n)(#{1,6}\s|[-*+]\s|\d+\.\s|>\s|```)|\[[^\]]+\]\([^)]+\)|\*\*[^*]+\*\*|_[^_]+_/m.test(input);
      }

      function normalizeInputText(input) {
        if (isLikelyHtml(input)) {
          return htmlToText(input);
        }

        if (isLikelyMarkdown(input)) {
          return markdownToText(input);
        }

        return input.trim();
      }

      function setStatus(message, isError = false) {
        statusEl.textContent = message;
        statusEl.style.color = isError ? "crimson" : "inherit";
      }

      function saveInputsToStorage() {
        localStorage.setItem(STORAGE_KEYS.text, textInput.value);
        localStorage.setItem(STORAGE_KEYS.voice, voiceSelect.value);
        localStorage.setItem(STORAGE_KEYS.rate, rateInput.value);
        localStorage.setItem(STORAGE_KEYS.pitch, pitchInput.value);
      }

      function restoreInputsFromStorage() {
        const savedText = localStorage.getItem(STORAGE_KEYS.text);
        const savedVoice = localStorage.getItem(STORAGE_KEYS.voice);
        const savedRate = localStorage.getItem(STORAGE_KEYS.rate);
        const savedPitch = localStorage.getItem(STORAGE_KEYS.pitch);

        if (savedText !== null) {
          textInput.value = savedText;
        }

        if (savedVoice !== null) {
          voiceSelect.value = savedVoice;
        }

        if (savedRate !== null) {
          rateInput.value = savedRate;
        }

        if (savedPitch !== null) {
          pitchInput.value = savedPitch;
        }

      }

      synthesizeBtn.addEventListener("click", async () => {
        const text = normalizeInputText(textInput.value);
        if (!text) {
          setStatus("Please enter text first.", true);
          return;
        }

        setStatus("Starting background synthesis...");

        try {
          const response = await fetch("/api/command", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              action: "synthesize",
              text,
              voice: voiceSelect.value,
              rate: rateInput.value.trim() || "+0%",
              pitch: pitchInput.value.trim() || "+0Hz",
            }),
          });

          if (!response.ok) {
            throw new Error(`Synthesis request failed: ${response.status}`);
          }

          const payload = await response.json();
          const recordId = payload.item?.id;
          setStatus(`Synthesis started in background${recordId ? ` (ID: ${recordId})` : ""}.`);
          loadHistory();
        } catch (error) {
          setStatus(`Failed to start synthesis: ${String(error)}`, true);
        }

        saveInputsToStorage();
      });

      textInput.addEventListener("input", saveInputsToStorage);
      voiceSelect.addEventListener("change", saveInputsToStorage);
      rateInput.addEventListener("input", saveInputsToStorage);
      pitchInput.addEventListener("input", saveInputsToStorage);
      refreshHistoryBtn.addEventListener("click", loadHistory);

      restoreInputsFromStorage();
      loadHistory();

      historyPollTimer = setInterval(loadHistory, 4000);
      window.addEventListener("beforeunload", () => {
        if (historyPollTimer) {
          clearInterval(historyPollTimer);
        }
      });
    </script>
  </body>
</html>

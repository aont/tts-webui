<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Edge TTS HTTP Demo</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: Inter, system-ui, sans-serif;
      }
      body {
        margin: 2rem;
        max-width: 900px;
      }
      textarea {
        width: 100%;
        min-height: 160px;
        margin-bottom: 1rem;
        padding: 0.7rem;
        font-size: 1rem;
      }
      select,
      input,
      button {
        padding: 0.6rem;
        font-size: 1rem;
      }
      .controls {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        flex-wrap: wrap;
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }
      .control-group input {
        width: 7rem;
      }
      .actions {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        margin-bottom: 1rem;
      }
      .history-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 1.2rem;
        margin-bottom: 0.6rem;
      }
      .history-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .history-item {
        border: 1px solid color-mix(in srgb, currentColor 25%, transparent);
        border-radius: 8px;
        padding: 0.7rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .history-item-main {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
      }
      .history-meta {
        font-size: 0.9rem;
        opacity: 0.85;
      }
      .history-preview {
        white-space: pre-wrap;
        word-break: break-word;
        margin: 0;
      }
      .history-item button {
        width: fit-content;
      }
      #status {
        min-height: 1.4rem;
        margin-bottom: 1rem;
      }
      audio {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h1>Speech Synthesis HTTP Demo</h1>
    <p>
      Enter text and synthesize speech using <code>edge-tts</code> or <code>voicevox</code>. Communication between frontend and backend happens via
      HTTP (GET/POST).
    </p>

    <textarea id="textInput" placeholder="Type text to synthesize..."></textarea>

    <div class="actions controls">
      <div class="control-group">
        <label for="engineSelect">Engine:</label>
        <select id="engineSelect">
          <option value="edge-tts">edge-tts</option>
          <option value="voicevox">voicevox</option>
        </select>
      </div>
      <div class="control-group">
        <label for="voiceSelect">Voice:</label>
        <select id="voiceSelect">
          <option value="en-US-JennyNeural">en-US-JennyNeural</option>
          <option value="en-US-GuyNeural">en-US-GuyNeural</option>
          <option value="en-GB-SoniaNeural">en-GB-SoniaNeural</option>
          <option value="ja-JP-NanamiNeural">ja-JP-NanamiNeural</option>
        </select>
      </div>
      <div class="control-group" id="voicevoxStyleGroup" hidden>
        <label for="voicevoxStyleSelect">Style:</label>
        <select id="voicevoxStyleSelect"></select>
      </div>
      <div class="control-group">
        <label for="rateInput">Rate:</label>
        <input id="rateInput" type="text" value="+0%" placeholder="e.g. +15%" />
      </div>
      <div class="control-group">
        <label for="pitchInput">Pitch:</label>
        <input id="pitchInput" type="text" value="+0Hz" placeholder="e.g. +5Hz" />
      </div>
      <button id="synthesizeBtn" type="button">Synthesize</button>
      <a id="downloadLink" href="#" download="speech.mp3" style="display: none">Download audio</a>
    </div>

    <div id="status"></div>
    <audio id="audioPlayer" controls></audio>

    <div class="history-header">
      <h2>Synthesis History</h2>
      <button id="refreshHistoryBtn" type="button">Refresh</button>
    </div>
    <ul id="historyList" class="history-list"></ul>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
      const statusEl = document.getElementById("status");
      const textInput = document.getElementById("textInput");
      const engineSelect = document.getElementById("engineSelect");
      const voiceSelect = document.getElementById("voiceSelect");
      const voicevoxStyleGroup = document.getElementById("voicevoxStyleGroup");
      const voicevoxStyleSelect = document.getElementById("voicevoxStyleSelect");
      const rateInput = document.getElementById("rateInput");
      const pitchInput = document.getElementById("pitchInput");
      const synthesizeBtn = document.getElementById("synthesizeBtn");
      const audioPlayer = document.getElementById("audioPlayer");
      const downloadLink = document.getElementById("downloadLink");
      const historyList = document.getElementById("historyList");
      const refreshHistoryBtn = document.getElementById("refreshHistoryBtn");

      const STORAGE_KEYS = {
        text: "edgeTtsWebUi.text",
        engine: "edgeTtsWebUi.engine",
        voice: "edgeTtsWebUi.voice",
        rate: "edgeTtsWebUi.rate",
        pitch: "edgeTtsWebUi.pitch",
        voicevoxStyle: "edgeTtsWebUi.voicevoxStyle",
      };

      let historyPollTimer;
      let pendingPlaybackRecordId = null;

      const EDGE_TTS_VOICES = [
        "en-US-JennyNeural",
        "en-US-GuyNeural",
        "en-GB-SoniaNeural",
        "ja-JP-NanamiNeural",
      ];
      let voicevoxSpeakers = [];
      let voicevoxStyles = [];

      function fillVoiceOptions(options, selected) {
        voiceSelect.innerHTML = options
          .map((option) => `<option value="${escapeHtml(String(option.value))}">${escapeHtml(option.label)}</option>`)
          .join("");

        if (selected !== null && selected !== undefined) {
          voiceSelect.value = String(selected);
        }

        if (!voiceSelect.value && options.length > 0) {
          voiceSelect.value = String(options[0].value);
        }
      }

      function updateVoiceOptions() {
        if (engineSelect.value === "voicevox") {
          const options = voicevoxSpeakers.map((speaker) => ({
            value: speaker.speaker_id,
            label: speaker.name,
          }));
          fillVoiceOptions(options, localStorage.getItem(STORAGE_KEYS.voice));
          updateVoicevoxStyleOptions();
          voicevoxStyleGroup.hidden = false;
          rateInput.disabled = true;
          pitchInput.disabled = true;
          return;
        }

        fillVoiceOptions(
          EDGE_TTS_VOICES.map((voice) => ({ value: voice, label: voice })),
          localStorage.getItem(STORAGE_KEYS.voice),
        );
        voicevoxStyles = [];
        voicevoxStyleSelect.innerHTML = "";
        voicevoxStyleGroup.hidden = true;
        rateInput.disabled = false;
        pitchInput.disabled = false;
      }

      function updateVoicevoxStyleOptions() {
        const selectedVoiceId = Number.parseInt(voiceSelect.value, 10);
        const selectedSpeaker = voicevoxSpeakers.find((speaker) => speaker.speaker_id === selectedVoiceId);
        voicevoxStyles = Array.isArray(selectedSpeaker?.styles) ? selectedSpeaker.styles : [];

        voicevoxStyleSelect.innerHTML = voicevoxStyles
          .map((style) => `<option value="${escapeHtml(String(style.id))}">${escapeHtml(String(style.name || "Unknown"))}</option>`)
          .join("");

        const savedStyleId = localStorage.getItem(STORAGE_KEYS.voicevoxStyle);
        if (savedStyleId && voicevoxStyles.some((style) => String(style.id) === savedStyleId)) {
          voicevoxStyleSelect.value = savedStyleId;
        }

        if (!voicevoxStyleSelect.value && voicevoxStyles.length > 0) {
          voicevoxStyleSelect.value = String(voicevoxStyles[0].id);
        }
      }

      async function loadVoicevoxSpeakers() {
        try {
          const response = await fetch("/api/command", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action: "voicevox_speakers" }),
          });

          if (!response.ok) {
            throw new Error(`VoiceVox speakers request failed: ${response.status}`);
          }

          const payload = await response.json();
          voicevoxSpeakers = Array.isArray(payload.items) ? payload.items : [];
        } catch (error) {
          voicevoxSpeakers = [];
          setStatus(`Failed to load VoiceVox speakers: ${String(error)}`, true);
        }
      }

      function escapeHtml(value) {
        return value
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll("\"", "&quot;")
          .replaceAll("'", "&#39;");
      }

      function truncateText(value, maxLength = 220) {
        return value.length > maxLength ? `${value.slice(0, maxLength)}...` : value;
      }

      function playHistoryAudio(recordId, audioFilename = "") {
        const audioUrl = `/api/history/${encodeURIComponent(recordId)}/audio`;
        audioPlayer.src = audioUrl;
        audioPlayer.play().catch(() => {
          // autoplay might be blocked by browser policy
        });
        downloadLink.href = audioUrl;
        downloadLink.download = audioFilename || `${recordId}.mp3`;
        downloadLink.style.display = "inline-block";
      }

      function renderHistory(records) {
        if (!records.length) {
          historyList.innerHTML = "<li class=\"history-item\">No synthesis history yet.</li>";
          return;
        }

        historyList.innerHTML = records
          .map((record) => {
            const createdAt = new Date(record.created_at);
            const createdAtLabel = Number.isNaN(createdAt.getTime()) ? "Unknown time" : createdAt.toLocaleString();
            const preview = escapeHtml(truncateText(record.text || ""));
            const status = escapeHtml(record.status || "unknown");
            const voiceLabel = escapeHtml(resolveVoiceLabel(record));
            const canPlay = Boolean(record.audio_filename);
            const canStop = record.status === "in_progress" || record.status === "stopping";
            const actionButtons = [
              canPlay
                ? `<button type=\"button\" data-record-id=\"${escapeHtml(record.id || "")}\" data-audio-filename=\"${escapeHtml(record.audio_filename || "")}\">Play</button>`
                : "",
              canStop
                ? `<button type=\"button\" data-stop-record-id=\"${escapeHtml(record.id || "")}\">Stop</button>`
                : "",
            ]
              .filter(Boolean)
              .join(" ");

            return `
              <li class=\"history-item\">
                <div class=\"history-item-main\">
                  <div class=\"history-meta\">
                    <strong>${voiceLabel}</strong>
                    <div>Engine: ${escapeHtml(record.engine || "edge-tts")}</div>
                    <div>${escapeHtml(record.rate || "")}, ${escapeHtml(record.pitch || "")}</div>
                    <div>${escapeHtml(createdAtLabel)}</div>
                    <div>Status: <strong>${status}</strong></div>
                  </div>
                  <div class="actions">${actionButtons || "<span></span>"}</div>
                </div>
                <p class=\"history-preview\">${preview}</p>
              </li>
            `;
          })
          .join("");

        historyList.querySelectorAll("button[data-record-id]").forEach((button) => {
          button.addEventListener("click", () => {
            const recordId = button.getAttribute("data-record-id");
            const audioFilename = button.getAttribute("data-audio-filename") || "";
            if (!recordId) return;
            playHistoryAudio(recordId, audioFilename);
          });
        });

        historyList.querySelectorAll("button[data-stop-record-id]").forEach((button) => {
          button.addEventListener("click", async () => {
            const recordId = button.getAttribute("data-stop-record-id");
            if (!recordId) return;

            try {
              const response = await fetch(`/api/command`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  action: "stop",
                  record_id: recordId,
                }),
              });
              if (!response.ok) {
                throw new Error(`Stop request failed: ${response.status}`);
              }

              setStatus("Stop requested for selected synthesis.");
              loadHistory();
            } catch (error) {
              setStatus(`Failed to stop synthesis: ${String(error)}`, true);
            }
          });
        });
      }

      function resolveVoiceLabel(record) {
        const rawVoice = String(record.voice || "unknown");
        if (record.engine !== "voicevox") {
          return rawVoice;
        }

        const styleId = Number.parseInt(rawVoice, 10);
        if (Number.isNaN(styleId)) {
          return rawVoice;
        }

        for (const speaker of voicevoxSpeakers) {
          if (!Array.isArray(speaker.styles)) {
            continue;
          }

          const matchedStyle = speaker.styles.find((style) => style.id === styleId);
          if (!matchedStyle) {
            continue;
          }

          const speakerName = speaker.name || "Unknown";
          const styleName = matchedStyle.name || "Unknown";
          return styleName ? `${speakerName} (${styleName})` : speakerName;
        }

        return rawVoice;
      }

      async function loadHistory() {
        try {
          const response = await fetch("/api/command", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action: "history_list" }),
          });
          if (!response.ok) {
            throw new Error(`History request failed: ${response.status}`);
          }

          const payload = await response.json();
          const records = Array.isArray(payload.items) ? payload.items : [];
          renderHistory(records);

          if (pendingPlaybackRecordId) {
            const pendingRecord = records.find((record) => record.id === pendingPlaybackRecordId);
            if (pendingRecord?.status === "completed" && pendingRecord.audio_filename) {
              playHistoryAudio(pendingPlaybackRecordId, pendingRecord.audio_filename);
              setStatus(`Synthesis completed (ID: ${pendingPlaybackRecordId}). Audio loaded to player.`);
              pendingPlaybackRecordId = null;
            } else if (["failed", "stopped"].includes(pendingRecord?.status || "")) {
              setStatus(`Synthesis finished with status: ${pendingRecord.status} (ID: ${pendingPlaybackRecordId}).`, true);
              pendingPlaybackRecordId = null;
            }
          }
        } catch (error) {
          historyList.innerHTML = `<li class=\"history-item\">Failed to load history: ${escapeHtml(String(error))}</li>`;
        }
      }

      function htmlToText(input) {
        const doc = new DOMParser().parseFromString(input, "text/html");
        return (doc.body.textContent || "").replace(/\s+\n/g, "\n").trim();
      }

      function markdownToText(input) {
        if (!window.marked || typeof window.marked.parse !== "function") {
          return input.trim();
        }

        const html = window.marked.parse(input);
        return htmlToText(html);
      }

      function isLikelyHtml(input) {
        return /<\/?[a-z][\s\S]*>/i.test(input);
      }

      function isLikelyMarkdown(input) {
        return /(^|\n)(#{1,6}\s|[-*+]\s|\d+\.\s|>\s|```)|\[[^\]]+\]\([^)]+\)|\*\*[^*]+\*\*|_[^_]+_/m.test(input);
      }

      function normalizeInputText(input) {
        if (isLikelyHtml(input)) {
          return htmlToText(input);
        }

        if (isLikelyMarkdown(input)) {
          return markdownToText(input);
        }

        return input.trim();
      }

      function setStatus(message, isError = false) {
        statusEl.textContent = message;
        statusEl.style.color = isError ? "crimson" : "inherit";
      }

      function saveInputsToStorage() {
        localStorage.setItem(STORAGE_KEYS.text, textInput.value);
        localStorage.setItem(STORAGE_KEYS.engine, engineSelect.value);
        localStorage.setItem(STORAGE_KEYS.voice, voiceSelect.value);
        localStorage.setItem(STORAGE_KEYS.rate, rateInput.value);
        localStorage.setItem(STORAGE_KEYS.pitch, pitchInput.value);
        localStorage.setItem(STORAGE_KEYS.voicevoxStyle, voicevoxStyleSelect.value);
      }

      function restoreInputsFromStorage() {
        const savedText = localStorage.getItem(STORAGE_KEYS.text);
        const savedEngine = localStorage.getItem(STORAGE_KEYS.engine);
        const savedVoice = localStorage.getItem(STORAGE_KEYS.voice);
        const savedRate = localStorage.getItem(STORAGE_KEYS.rate);
        const savedPitch = localStorage.getItem(STORAGE_KEYS.pitch);
        const savedVoicevoxStyle = localStorage.getItem(STORAGE_KEYS.voicevoxStyle);

        if (savedText !== null) {
          textInput.value = savedText;
        }

        if (savedEngine !== null) {
          engineSelect.value = savedEngine;
        }

        if (savedVoice !== null) {
          voiceSelect.value = savedVoice;
        }

        if (savedRate !== null) {
          rateInput.value = savedRate;
        }

        if (savedPitch !== null) {
          pitchInput.value = savedPitch;
        }

        if (savedVoicevoxStyle !== null) {
          voicevoxStyleSelect.value = savedVoicevoxStyle;
        }
      }

      synthesizeBtn.addEventListener("click", async () => {
        const text = normalizeInputText(textInput.value);
        if (!text) {
          setStatus("Please enter text first.", true);
          return;
        }

        setStatus("Starting background synthesis...");

        try {
          const response = await fetch("/api/command", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              action: "synthesize",
              text,
              engine: engineSelect.value,
              voice: engineSelect.value === "voicevox" ? voicevoxStyleSelect.value : voiceSelect.value,
              style: engineSelect.value === "voicevox"
                ? (voicevoxStyles.find((item) => String(item.id) === voicevoxStyleSelect.value)?.name || "")
                : "",
              rate: rateInput.value.trim() || "+0%",
              pitch: pitchInput.value.trim() || "+0Hz",
            }),
          });

          if (!response.ok) {
            throw new Error(`Synthesis request failed: ${response.status}`);
          }

          const payload = await response.json();
          const recordId = payload.item?.id;
          pendingPlaybackRecordId = recordId || null;
          setStatus(`Synthesis started in background${recordId ? ` (ID: ${recordId})` : ""}.`);
          loadHistory();
        } catch (error) {
          setStatus(`Failed to start synthesis: ${String(error)}`, true);
        }

        saveInputsToStorage();
      });

      textInput.addEventListener("input", saveInputsToStorage);
      engineSelect.addEventListener("change", () => {
        updateVoiceOptions();
        saveInputsToStorage();
      });
      voiceSelect.addEventListener("change", () => {
        if (engineSelect.value === "voicevox") {
          updateVoicevoxStyleOptions();
        }
        saveInputsToStorage();
      });
      voicevoxStyleSelect.addEventListener("change", saveInputsToStorage);
      rateInput.addEventListener("input", saveInputsToStorage);
      pitchInput.addEventListener("input", saveInputsToStorage);
      refreshHistoryBtn.addEventListener("click", loadHistory);

      (async () => {
        await loadVoicevoxSpeakers();
        restoreInputsFromStorage();
        updateVoiceOptions();
        loadHistory();
      })();

      historyPollTimer = setInterval(loadHistory, 4000);
      window.addEventListener("beforeunload", () => {
        if (historyPollTimer) {
          clearInterval(historyPollTimer);
        }
      });
    </script>
  </body>
</html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Edge TTS HTTP Demo</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: Inter, system-ui, sans-serif;
      }
      body {
        margin: 2rem;
        max-width: 900px;
      }
      textarea {
        width: 100%;
        min-height: 160px;
        margin-bottom: 1rem;
        padding: 0.7rem;
        font-size: 1rem;
      }
      select,
      input,
      button {
        padding: 0.6rem;
        font-size: 1rem;
      }
      .controls {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        flex-wrap: wrap;
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }
      .control-group.endpoint-group {
        min-width: min(420px, 100%);
        flex: 1 1 340px;
      }
      .control-group.endpoint-group input {
        width: 100%;
      }
      .control-group input {
        width: 7rem;
      }
      .actions {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        margin-bottom: 1rem;
      }
      .history-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 1.2rem;
        margin-bottom: 0.6rem;
      }
      .history-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .history-item {
        border: 1px solid color-mix(in srgb, currentColor 25%, transparent);
        border-radius: 8px;
        padding: 0.7rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .history-item-main {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
      }
      .history-meta {
        font-size: 0.9rem;
        opacity: 0.85;
      }
      .history-preview {
        white-space: pre-wrap;
        word-break: break-word;
        margin: 0;
      }
      .history-item button {
        width: fit-content;
      }
      #status {
        min-height: 1.4rem;
        margin-bottom: 1rem;
      }
      audio {
        width: 100%;
      }
      .segment-panel {
        border: 1px solid color-mix(in srgb, currentColor 25%, transparent);
        border-radius: 8px;
        padding: 0.8rem;
        margin-bottom: 1rem;
      }
      .segment-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.6rem;
        flex-wrap: wrap;
      }
      .segment-controls {
        display: flex;
        gap: 0.6rem;
        align-items: center;
        flex-wrap: wrap;
      }
      .segment-controls input {
        width: 7rem;
      }
      .segment-list {
        list-style: none;
        margin: 0.8rem 0 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .segment-item {
        border: 1px solid color-mix(in srgb, currentColor 20%, transparent);
        border-radius: 6px;
        padding: 0.5rem;
      }
      .segment-item p {
        margin: 0.3rem 0;
        white-space: pre-wrap;
        word-break: break-word;
      }
    </style>
  </head>
  <body>
    <h1>Speech Synthesis HTTP Demo</h1>
    <p>
      Enter text and synthesize speech using <code>edge-tts</code>, <code>voicevox</code>, or <code>pyaitalk</code>. Communication between frontend and backend happens via
      HTTP (GET/POST).
    </p>

    <textarea id="textInput" placeholder="Type text to synthesize..."></textarea>

    <section class="segment-panel">
      <div class="segment-header">
        <strong id="segmentTitle">Segments</strong>
        <div class="segment-controls">
          <label for="maxSegmentCharsInput">Max chars:</label>
          <input id="maxSegmentCharsInput" type="number" min="1" max="3000" step="1" value="3000" />
          <label for="maxSplitPointsInput">Max split points:</label>
          <input id="maxSplitPointsInput" type="number" min="0" max="200" step="1" value="0" />
          <button id="rebuildSegmentsBtn" type="button">Rebuild</button>
        </div>
      </div>
      <ul id="segmentList" class="segment-list"></ul>
    </section>

    <div class="actions controls">
      <div class="control-group endpoint-group">
        <label for="endpointInput">API Endpoint:</label>
        <input id="endpointInput" type="text" placeholder="e.g. http://127.0.0.1:8080" />
      </div>
      <div class="control-group">
        <label for="engineSelect">Engine:</label>
        <select id="engineSelect">
          <option value="edge-tts">edge-tts</option>
          <option value="voicevox">voicevox</option>
          <option value="pyaitalk">pyaitalk</option>
        </select>
      </div>
      <div class="control-group">
        <label for="voiceSelect">Voice:</label>
        <select id="voiceSelect">
          <option value="en-US-JennyNeural">en-US-JennyNeural</option>
          <option value="en-US-GuyNeural">en-US-GuyNeural</option>
          <option value="en-GB-SoniaNeural">en-GB-SoniaNeural</option>
          <option value="ja-JP-NanamiNeural">ja-JP-NanamiNeural</option>
        </select>
      </div>
      <div class="control-group" id="voicevoxStyleGroup" hidden>
        <label for="voicevoxStyleSelect">Style:</label>
        <select id="voicevoxStyleSelect"></select>
      </div>
      <div class="control-group">
        <label for="rateInput">Rate:</label>
        <input id="rateInput" type="text" value="+0%" placeholder="e.g. +15%" />
      </div>
      <div class="control-group">
        <label for="pitchInput">Pitch:</label>
        <input id="pitchInput" type="text" value="+0Hz" placeholder="e.g. +5Hz" />
      </div>
      <button id="synthesizeBtn" type="button">Synthesize</button>
      <a id="downloadLink" href="#" download="speech.mp3" style="display: none">Download audio</a>
    </div>

    <div id="status"></div>
    <audio id="audioPlayer" controls></audio>

    <div class="history-header">
      <h2>Synthesis History</h2>
      <button id="refreshHistoryBtn" type="button">Refresh</button>
    </div>
    <ul id="historyList" class="history-list"></ul>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
      const statusEl = document.getElementById("status");
      const textInput = document.getElementById("textInput");
      const endpointInput = document.getElementById("endpointInput");
      const engineSelect = document.getElementById("engineSelect");
      const voiceSelect = document.getElementById("voiceSelect");
      const voicevoxStyleGroup = document.getElementById("voicevoxStyleGroup");
      const voicevoxStyleSelect = document.getElementById("voicevoxStyleSelect");
      const rateInput = document.getElementById("rateInput");
      const pitchInput = document.getElementById("pitchInput");
      const synthesizeBtn = document.getElementById("synthesizeBtn");
      const audioPlayer = document.getElementById("audioPlayer");
      const downloadLink = document.getElementById("downloadLink");
      const historyList = document.getElementById("historyList");
      const refreshHistoryBtn = document.getElementById("refreshHistoryBtn");
      const rebuildSegmentsBtn = document.getElementById("rebuildSegmentsBtn");
      const segmentList = document.getElementById("segmentList");
      const segmentTitle = document.getElementById("segmentTitle");
      const maxSegmentCharsInput = document.getElementById("maxSegmentCharsInput");
      const maxSplitPointsInput = document.getElementById("maxSplitPointsInput");
      const DEFAULT_MAX_SEGMENT_CHARS = 3000;
      const DEFAULT_MAX_SPLIT_POINTS = 0;
      const MAX_SPLIT_POINTS_LIMIT = 200;
      const SENTENCE_END_CHARS = new Set(["。", "．", ".", "!", "?", "！", "？", "\n"]);
      const TRAILING_CLOSERS = /^[\s\"'\)\]\}」』】》〉》）】”’]+$/;

      const STORAGE_KEYS = {
        text: "edgeTtsWebUi.text",
        endpoint: "edgeTtsWebUi.endpoint",
        engine: "edgeTtsWebUi.engine",
        voice: "edgeTtsWebUi.voice",
        rate: "edgeTtsWebUi.rate",
        pitch: "edgeTtsWebUi.pitch",
        voicevoxStyle: "edgeTtsWebUi.voicevoxStyle",
        pyaitalkVoice: "edgeTtsWebUi.pyaitalkVoice",
        maxSegmentChars: "edgeTtsWebUi.maxSegmentChars",
        maxSplitPoints: "edgeTtsWebUi.maxSplitPoints",
      };

      let historyPollTimer;
      let pendingPlaybackRecordId = null;
      let segmentState = {
        text: "",
        boundaries: [],
        candidates: [],
      };

      function debugLog(message, details) {
        if (details === undefined) {
          console.debug(`[tts-webui] ${message}`);
          return;
        }
        console.debug(`[tts-webui] ${message}`, details);
      }

      const EDGE_TTS_VOICES = [
        "en-US-JennyNeural",
        "en-US-GuyNeural",
        "en-GB-SoniaNeural",
        "ja-JP-NanamiNeural",
      ];
      let voicevoxSpeakers = [];
      let voicevoxStyles = [];
      let pyaitalkVoices = [];

      function getDefaultEndpoint() {
        if (window.location.protocol.startsWith("http")) {
          return window.location.origin;
        }
        return "http://127.0.0.1:8080";
      }

      function normalizeEndpointUrl(rawValue) {
        const value = String(rawValue || "").trim();
        if (!value) {
          return getDefaultEndpoint();
        }

        try {
          return new URL(value).origin;
        } catch {
          throw new Error("Invalid endpoint URL. Include protocol, e.g. http://127.0.0.1:8080");
        }
      }

      function getApiUrl(path) {
        const endpoint = normalizeEndpointUrl(endpointInput.value);
        return `${endpoint}${path}`;
      }

      function fillVoiceOptions(options, selected) {
        debugLog("Filling voice options", { count: options.length, selected });
        voiceSelect.innerHTML = options
          .map((option) => `<option value="${escapeHtml(String(option.value))}">${escapeHtml(option.label)}</option>`)
          .join("");

        if (selected !== null && selected !== undefined) {
          voiceSelect.value = String(selected);
        }

        if (!voiceSelect.value && options.length > 0) {
          voiceSelect.value = String(options[0].value);
        }
      }

      function updateVoiceOptions() {
        debugLog("Updating voice options", { engine: engineSelect.value });
        if (engineSelect.value === "voicevox") {
          const options = voicevoxSpeakers.map((speaker) => ({
            value: speaker.speaker_id,
            label: speaker.name,
          }));
          fillVoiceOptions(options, localStorage.getItem(STORAGE_KEYS.voice));
          updateVoicevoxStyleOptions();
          voicevoxStyleGroup.hidden = false;
          rateInput.disabled = true;
          pitchInput.disabled = true;
          return;
        }

        if (engineSelect.value === "pyaitalk") {
          fillVoiceOptions(
            pyaitalkVoices.map((voice) => ({ value: voice.id, label: voice.name })),
            localStorage.getItem(STORAGE_KEYS.pyaitalkVoice) || localStorage.getItem(STORAGE_KEYS.voice),
          );
          voicevoxStyles = [];
          voicevoxStyleSelect.innerHTML = "";
          voicevoxStyleGroup.hidden = true;
          rateInput.disabled = true;
          pitchInput.disabled = true;
          return;
        }

        fillVoiceOptions(
          EDGE_TTS_VOICES.map((voice) => ({ value: voice, label: voice })),
          localStorage.getItem(STORAGE_KEYS.voice),
        );
        voicevoxStyles = [];
        voicevoxStyleSelect.innerHTML = "";
        voicevoxStyleGroup.hidden = true;
        rateInput.disabled = false;
        pitchInput.disabled = false;
      }

      function updateVoicevoxStyleOptions() {
        debugLog("Updating VoiceVox style options", { selectedVoice: voiceSelect.value });
        const selectedVoiceId = Number.parseInt(voiceSelect.value, 10);
        const selectedSpeaker = voicevoxSpeakers.find((speaker) => speaker.speaker_id === selectedVoiceId);
        voicevoxStyles = Array.isArray(selectedSpeaker?.styles) ? selectedSpeaker.styles : [];

        voicevoxStyleSelect.innerHTML = voicevoxStyles
          .map((style) => `<option value="${escapeHtml(String(style.id))}">${escapeHtml(String(style.name || "Unknown"))}</option>`)
          .join("");

        const savedStyleId = localStorage.getItem(STORAGE_KEYS.voicevoxStyle);
        if (savedStyleId && voicevoxStyles.some((style) => String(style.id) === savedStyleId)) {
          voicevoxStyleSelect.value = savedStyleId;
        }

        if (!voicevoxStyleSelect.value && voicevoxStyles.length > 0) {
          voicevoxStyleSelect.value = String(voicevoxStyles[0].id);
        }
      }

      async function loadVoicevoxSpeakers() {
        debugLog("Loading VoiceVox speakers");
        try {
          const response = await fetch(getApiUrl("/api/command"), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action: "voicevox_speakers" }),
          });

          if (!response.ok) {
            throw new Error(`VoiceVox speakers request failed: ${response.status}`);
          }

          const payload = await response.json();
          voicevoxSpeakers = Array.isArray(payload.items) ? payload.items : [];
          debugLog("Loaded VoiceVox speakers", { count: voicevoxSpeakers.length });
        } catch (error) {
          debugLog("Failed to load VoiceVox speakers", error);
          voicevoxSpeakers = [];
          setStatus(`Failed to load VoiceVox speakers: ${String(error)}`, true);
        }
      }


      async function loadPyaitalkVoices() {
        debugLog("Loading pyaitalk voices");
        try {
          const response = await fetch(getApiUrl("/api/command"), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action: "pyaitalk_voices" }),
          });

          if (!response.ok) {
            throw new Error(`pyaitalk voices request failed: ${response.status}`);
          }

          const payload = await response.json();
          pyaitalkVoices = Array.isArray(payload.items) ? payload.items : [];
          debugLog("Loaded pyaitalk voices", { count: pyaitalkVoices.length });
        } catch (error) {
          debugLog("Failed to load pyaitalk voices", error);
          pyaitalkVoices = [];
          setStatus(`Failed to load pyaitalk voices: ${String(error)}`, true);
        }
      }

      function escapeHtml(value) {
        return value
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll("\"", "&quot;")
          .replaceAll("'", "&#39;");
      }

      function truncateText(value, maxLength = 220) {
        return value.length > maxLength ? `${value.slice(0, maxLength)}...` : value;
      }

      function collectSentenceCandidates(text) {
        const candidates = new Set();
        for (let i = 0; i < text.length; i += 1) {
          const char = text[i];
          if (!SENTENCE_END_CHARS.has(char)) {
            continue;
          }

          let end = i + 1;
          while (end < text.length && TRAILING_CLOSERS.test(text[end])) {
            end += 1;
          }
          candidates.add(end);
        }
        candidates.add(text.length);
        return [...candidates].filter((point) => point > 0).sort((a, b) => a - b);
      }

      function parsePositiveInt(value, fallback, min = 1, max = Number.POSITIVE_INFINITY) {
        const parsed = Number.parseInt(String(value), 10);
        if (!Number.isInteger(parsed)) {
          return fallback;
        }
        return Math.min(Math.max(parsed, min), max);
      }

      function getSegmentationSettings() {
        const maxChars = parsePositiveInt(maxSegmentCharsInput.value, DEFAULT_MAX_SEGMENT_CHARS, 1, DEFAULT_MAX_SEGMENT_CHARS);
        const maxSplitPoints = parsePositiveInt(maxSplitPointsInput.value, DEFAULT_MAX_SPLIT_POINTS, 0, MAX_SPLIT_POINTS_LIMIT);
        return { maxChars, maxSplitPoints };
      }

      function updateSegmentTitle() {
        const { maxChars, maxSplitPoints } = getSegmentationSettings();
        const splitPointsLabel = maxSplitPoints > 0 ? `${maxSplitPoints}` : "auto";
        segmentTitle.textContent = `Segments (max ${maxChars} chars, split points: ${splitPointsLabel})`;
      }

      function buildSegmentBoundaries(text, maxChars = DEFAULT_MAX_SEGMENT_CHARS, maxSplitPoints = DEFAULT_MAX_SPLIT_POINTS) {
        if (!text) {
          return { boundaries: [], candidates: [] };
        }

        const candidates = collectSentenceCandidates(text);
        const boundaries = [];
        let start = 0;

        while (start < text.length) {
          const maxEnd = Math.min(start + maxChars, text.length);
          let selected = -1;

          for (const point of candidates) {
            if (point <= start || point > maxEnd) {
              continue;
            }
            selected = point;
          }

          if (selected === -1) {
            selected = maxEnd;
          }

          boundaries.push(selected);
          start = selected;

          if (maxSplitPoints > 0 && boundaries.length >= maxSplitPoints + 1 && start < text.length) {
            boundaries[boundaries.length - 1] = text.length;
            break;
          }
        }

        return { boundaries, candidates };
      }

      function getCurrentSegments() {
        const segments = [];
        let start = 0;
        for (const end of segmentState.boundaries) {
          const segment = segmentState.text.slice(start, end).trim();
          if (segment) {
            segments.push(segment);
          }
          start = end;
        }
        return segments;
      }
      function getBoundaryMoveTargets(index) {
        if (index < 0 || index >= segmentState.boundaries.length - 1) {
          return { backward: null, forward: null };
        }

        const previousEdge = index === 0 ? 0 : segmentState.boundaries[index - 1];
        const currentEdge = segmentState.boundaries[index];
        const nextEdge = segmentState.boundaries[index + 1];

        const options = segmentState.candidates
          .filter((point) => {
            if (point <= previousEdge || point >= nextEdge || point === currentEdge) {
              return false;
            }
            const { maxChars } = getSegmentationSettings();
            return point - previousEdge <= maxChars && nextEdge - point <= maxChars;
          })
          .sort((a, b) => a - b);

        return {
          backward: options.filter((value) => value < currentEdge).at(-1) ?? null,
          forward: options.find((value) => value > currentEdge) ?? null,
        };
      }

      function moveBoundary(index, direction) {
        const targets = getBoundaryMoveTargets(index);
        const target = direction === "backward" ? targets.backward : targets.forward;

        if (!target) {
          return;
        }

        segmentState.boundaries[index] = target;
        renderSegments();
      }

      function renderSegments() {
        const segments = getCurrentSegments();
        if (!segments.length) {
          segmentList.innerHTML = "<li class=\"segment-item\">No text.</li>";
          return;
        }

        const SEGMENT_PREVIEW_CHARS = 20;
        const canMoveBoundaries = segments.length > 1;

        segmentList.innerHTML = segments
          .map((segment, index) => {
            const segmentBeginning = segment.slice(0, SEGMENT_PREVIEW_CHARS);
            const segmentEnd = segment.slice(-SEGMENT_PREVIEW_CHARS);
            const segmentPreview = segment.length > SEGMENT_PREVIEW_CHARS * 2
              ? `${escapeHtml(segmentBeginning)}...${escapeHtml(segmentEnd)}`
              : escapeHtml(segment);
            let moveButtons = "";
            if (canMoveBoundaries && index < segments.length - 1) {
              const targets = getBoundaryMoveTargets(index);
              moveButtons = `<div class="actions"><button type="button" data-move-boundary="${index}" data-direction="backward" ${targets.backward ? "" : "disabled"}>← Move split earlier</button><button type="button" data-move-boundary="${index}" data-direction="forward" ${targets.forward ? "" : "disabled"}>Move split later →</button></div>`;
            }
            return `<li class=\"segment-item\"><strong>Segment ${index + 1} (${segment.length} chars)</strong><p>${segmentPreview}</p>${moveButtons}</li>`;
          })
          .join("");

        segmentList.querySelectorAll("button[data-move-boundary]").forEach((button) => {
          button.addEventListener("click", () => {
            const index = Number.parseInt(button.getAttribute("data-move-boundary") || "-1", 10);
            const direction = button.getAttribute("data-direction") || "forward";
            moveBoundary(index, direction);
          });
        });
      }

      function rebuildSegmentsFromInput() {
        const text = normalizeInputText(textInput.value);
        const { maxChars, maxSplitPoints } = getSegmentationSettings();
        const { boundaries, candidates } = buildSegmentBoundaries(text, maxChars, maxSplitPoints);
        segmentState = { text, boundaries, candidates };
        updateSegmentTitle();
        renderSegments();
      }

      function playHistoryAudio(recordId, audioFilename = "") {
        debugLog("Playing history audio", { recordId, audioFilename });
        const audioUrl = getApiUrl(`/api/history/${encodeURIComponent(recordId)}/audio`);
        audioPlayer.src = audioUrl;
        audioPlayer.play().catch(() => {
          // autoplay might be blocked by browser policy
        });
        downloadLink.href = audioUrl;
        downloadLink.download = audioFilename || `${recordId}.mp3`;
        downloadLink.style.display = "inline-block";
      }

      function renderHistory(records) {
        debugLog("Rendering history", { count: records.length });
        if (!records.length) {
          historyList.innerHTML = "<li class=\"history-item\">No synthesis history yet.</li>";
          return;
        }

        historyList.innerHTML = records
          .map((record) => {
            const createdAt = new Date(record.created_at);
            const createdAtLabel = Number.isNaN(createdAt.getTime()) ? "Unknown time" : createdAt.toLocaleString();
            const preview = escapeHtml(truncateText(record.text || ""));
            const status = escapeHtml(record.status || "unknown");
            const voiceLabel = escapeHtml(resolveVoiceLabel(record));
            const canPlay = Boolean(record.audio_filename);
            const canStop = record.status === "in_progress" || record.status === "stopping";
            const actionButtons = [
              canPlay
                ? `<button type=\"button\" data-record-id=\"${escapeHtml(record.id || "")}\" data-audio-filename=\"${escapeHtml(record.audio_filename || "")}\">Play</button>`
                : "",
              canStop
                ? `<button type=\"button\" data-stop-record-id=\"${escapeHtml(record.id || "")}\">Stop</button>`
                : "",
            ]
              .filter(Boolean)
              .join(" ");

            return `
              <li class=\"history-item\">
                <div class=\"history-item-main\">
                  <div class=\"history-meta\">
                    <strong>${voiceLabel}</strong>
                    <div>Engine: ${escapeHtml(record.engine || "edge-tts")}</div>
                    <div>${escapeHtml(record.rate || "")}, ${escapeHtml(record.pitch || "")}</div>
                    <div>${escapeHtml(createdAtLabel)}</div>
                    <div>Status: <strong>${status}</strong></div>
                  </div>
                  <div class="actions">${actionButtons || "<span></span>"}</div>
                </div>
                <p class=\"history-preview\">${preview}</p>
              </li>
            `;
          })
          .join("");

        historyList.querySelectorAll("button[data-record-id]").forEach((button) => {
          button.addEventListener("click", () => {
            const recordId = button.getAttribute("data-record-id");
            const audioFilename = button.getAttribute("data-audio-filename") || "";
            if (!recordId) return;
            playHistoryAudio(recordId, audioFilename);
          });
        });

        historyList.querySelectorAll("button[data-stop-record-id]").forEach((button) => {
          button.addEventListener("click", async () => {
            const recordId = button.getAttribute("data-stop-record-id");
            if (!recordId) return;

            try {
              const response = await fetch(getApiUrl("/api/command"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  action: "stop",
                  record_id: recordId,
                }),
              });
              if (!response.ok) {
                throw new Error(`Stop request failed: ${response.status}`);
              }

              setStatus("Stop requested for selected synthesis.");
              loadHistory();
            } catch (error) {
              setStatus(`Failed to stop synthesis: ${String(error)}`, true);
            }
          });
        });
      }

      function resolveVoiceLabel(record) {
        const rawVoice = String(record.voice || "unknown");
        if (record.engine !== "voicevox") {
          return rawVoice;
        }

        const styleId = Number.parseInt(rawVoice, 10);
        if (Number.isNaN(styleId)) {
          return rawVoice;
        }

        for (const speaker of voicevoxSpeakers) {
          if (!Array.isArray(speaker.styles)) {
            continue;
          }

          const matchedStyle = speaker.styles.find((style) => style.id === styleId);
          if (!matchedStyle) {
            continue;
          }

          const speakerName = speaker.name || "Unknown";
          const styleName = matchedStyle.name || "Unknown";
          return styleName ? `${speakerName} (${styleName})` : speakerName;
        }

        return rawVoice;
      }

      async function loadHistory() {
        debugLog("Loading history");
        try {
          const response = await fetch(getApiUrl("/api/command"), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action: "history_list" }),
          });
          if (!response.ok) {
            throw new Error(`History request failed: ${response.status}`);
          }

          const payload = await response.json();
          const records = Array.isArray(payload.items) ? payload.items : [];
          debugLog("History loaded", { count: records.length });
          renderHistory(records);

          if (pendingPlaybackRecordId) {
            const pendingRecord = records.find((record) => record.id === pendingPlaybackRecordId);
            if (pendingRecord?.status === "completed" && pendingRecord.audio_filename) {
              playHistoryAudio(pendingPlaybackRecordId, pendingRecord.audio_filename);
              setStatus(`Synthesis completed (ID: ${pendingPlaybackRecordId}). Audio loaded to player.`);
              pendingPlaybackRecordId = null;
            } else if (["failed", "stopped"].includes(pendingRecord?.status || "")) {
              setStatus(`Synthesis finished with status: ${pendingRecord.status} (ID: ${pendingPlaybackRecordId}).`, true);
              pendingPlaybackRecordId = null;
            }
          }
        } catch (error) {
          historyList.innerHTML = `<li class=\"history-item\">Failed to load history: ${escapeHtml(String(error))}</li>`;
        }
      }

      function htmlToText(input) {
        const doc = new DOMParser().parseFromString(input, "text/html");
        return (doc.body.textContent || "").replace(/\s+\n/g, "\n").trim();
      }

      function markdownToText(input) {
        if (!window.marked || typeof window.marked.parse !== "function") {
          return input.trim();
        }

        const html = window.marked.parse(input);
        return htmlToText(html);
      }

      function isLikelyHtml(input) {
        return /<\/?[a-z][\s\S]*>/i.test(input);
      }

      function normalizeInputText(input) {
        const rawInput = String(input || "").trim();
        if (!rawInput) {
          return "";
        }

        if (isLikelyHtml(input)) {
          return htmlToText(rawInput);
        }

        return markdownToText(rawInput);
      }

      function setStatus(message, isError = false) {
        debugLog("Status updated", { message, isError });
        statusEl.textContent = message;
        statusEl.style.color = isError ? "crimson" : "inherit";
      }

      function saveInputsToStorage() {
        localStorage.setItem(STORAGE_KEYS.text, textInput.value);
        localStorage.setItem(STORAGE_KEYS.endpoint, endpointInput.value.trim());
        localStorage.setItem(STORAGE_KEYS.engine, engineSelect.value);
        localStorage.setItem(STORAGE_KEYS.voice, voiceSelect.value);
        localStorage.setItem(STORAGE_KEYS.pyaitalkVoice, voiceSelect.value);
        localStorage.setItem(STORAGE_KEYS.rate, rateInput.value);
        localStorage.setItem(STORAGE_KEYS.pitch, pitchInput.value);
        localStorage.setItem(STORAGE_KEYS.voicevoxStyle, voicevoxStyleSelect.value);
        localStorage.setItem(STORAGE_KEYS.maxSegmentChars, String(getSegmentationSettings().maxChars));
        localStorage.setItem(STORAGE_KEYS.maxSplitPoints, String(getSegmentationSettings().maxSplitPoints));
      }

      function restoreInputsFromStorage() {
        const savedText = localStorage.getItem(STORAGE_KEYS.text);
        const savedEndpoint = localStorage.getItem(STORAGE_KEYS.endpoint);
        const savedEngine = localStorage.getItem(STORAGE_KEYS.engine);
        const savedVoice = localStorage.getItem(STORAGE_KEYS.voice);
        const savedRate = localStorage.getItem(STORAGE_KEYS.rate);
        const savedPitch = localStorage.getItem(STORAGE_KEYS.pitch);
        const savedVoicevoxStyle = localStorage.getItem(STORAGE_KEYS.voicevoxStyle);
        const savedPyaitalkVoice = localStorage.getItem(STORAGE_KEYS.pyaitalkVoice);
        const savedMaxSegmentChars = localStorage.getItem(STORAGE_KEYS.maxSegmentChars);
        const savedMaxSplitPoints = localStorage.getItem(STORAGE_KEYS.maxSplitPoints);

        if (savedText !== null) {
          textInput.value = savedText;
        }

        endpointInput.value = savedEndpoint !== null ? savedEndpoint : getDefaultEndpoint();

        if (savedEngine !== null) {
          engineSelect.value = savedEngine;
        }

        if (savedVoice !== null) {
          voiceSelect.value = savedVoice;
        }

        if (savedPyaitalkVoice !== null && savedEngine === "pyaitalk") {
          voiceSelect.value = savedPyaitalkVoice;
        }

        if (savedRate !== null) {
          rateInput.value = savedRate;
        }

        if (savedPitch !== null) {
          pitchInput.value = savedPitch;
        }

        if (savedVoicevoxStyle !== null) {
          voicevoxStyleSelect.value = savedVoicevoxStyle;
        }

        maxSegmentCharsInput.value = String(
          parsePositiveInt(savedMaxSegmentChars, DEFAULT_MAX_SEGMENT_CHARS, 1, DEFAULT_MAX_SEGMENT_CHARS),
        );
        maxSplitPointsInput.value = String(
          parsePositiveInt(savedMaxSplitPoints, DEFAULT_MAX_SPLIT_POINTS, 0, MAX_SPLIT_POINTS_LIMIT),
        );
      }

      synthesizeBtn.addEventListener("click", async () => {
        debugLog("Synthesize button clicked");
        const text = normalizeInputText(textInput.value);
        rebuildSegmentsFromInput();
        if (!text) {
          setStatus("Please enter text first.", true);
          return;
        }

        setStatus("Starting background synthesis...");

        try {
          const response = await fetch(getApiUrl("/api/command"), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              action: "synthesize",
              text,
              segments: getCurrentSegments(),
              engine: engineSelect.value,
              voice: engineSelect.value === "voicevox" ? voicevoxStyleSelect.value : voiceSelect.value,
              style: engineSelect.value === "voicevox"
                ? (voicevoxStyles.find((item) => String(item.id) === voicevoxStyleSelect.value)?.name || "")
                : "",
              rate: rateInput.value.trim() || "+0%",
              pitch: pitchInput.value.trim() || "+0Hz",
            }),
          });

          if (!response.ok) {
            throw new Error(`Synthesis request failed: ${response.status}`);
          }

          const payload = await response.json();
          const recordId = payload.item?.id;
          debugLog("Synthesis request accepted", { recordId });
          pendingPlaybackRecordId = recordId || null;
          setStatus(`Synthesis started in background${recordId ? ` (ID: ${recordId})` : ""}.`);
          loadHistory();
        } catch (error) {
          debugLog("Failed to start synthesis", error);
          setStatus(`Failed to start synthesis: ${String(error)}`, true);
        }

        saveInputsToStorage();
      });

      textInput.addEventListener("input", saveInputsToStorage);
      textInput.addEventListener("input", rebuildSegmentsFromInput);
      maxSegmentCharsInput.addEventListener("input", () => {
        saveInputsToStorage();
        rebuildSegmentsFromInput();
      });
      maxSplitPointsInput.addEventListener("input", () => {
        saveInputsToStorage();
        rebuildSegmentsFromInput();
      });
      endpointInput.addEventListener("change", async () => {
        try {
          endpointInput.value = normalizeEndpointUrl(endpointInput.value);
          saveInputsToStorage();
          setStatus("API endpoint updated.");
          await loadVoicevoxSpeakers();
          await loadPyaitalkVoices();
          updateVoiceOptions();
          loadHistory();
        } catch (error) {
          setStatus(String(error), true);
        }
      });
      engineSelect.addEventListener("change", () => {
        updateVoiceOptions();
        saveInputsToStorage();
      });
      voiceSelect.addEventListener("change", () => {
        if (engineSelect.value === "voicevox") {
          updateVoicevoxStyleOptions();
        }
        saveInputsToStorage();
      });
      voicevoxStyleSelect.addEventListener("change", saveInputsToStorage);
      rateInput.addEventListener("input", saveInputsToStorage);
      pitchInput.addEventListener("input", saveInputsToStorage);
      refreshHistoryBtn.addEventListener("click", loadHistory);
      rebuildSegmentsBtn.addEventListener("click", rebuildSegmentsFromInput);

      (async () => {
        debugLog("Initializing frontend state");
        restoreInputsFromStorage();
        try {
          endpointInput.value = normalizeEndpointUrl(endpointInput.value);
        } catch (error) {
          debugLog("Invalid saved API endpoint. Falling back to default.", error);
          endpointInput.value = getDefaultEndpoint();
        }
        await loadVoicevoxSpeakers();
        await loadPyaitalkVoices();
        rebuildSegmentsFromInput();
        updateVoiceOptions();
        loadHistory();
      })();

      historyPollTimer = setInterval(loadHistory, 4000);
      window.addEventListener("beforeunload", () => {
        if (historyPollTimer) {
          clearInterval(historyPollTimer);
        }
      });
    </script>
  </body>
</html>
